# v0.3 Anchor Identity Design

**Status:** Design locked (pre-implementation)
**Depends on:** v0.2.2 freeze (real pilot must complete first)

## Core Principle

> An anchor node is identity-defined by the bytes it anchors to — not by how humans refer to it.

URLs, labels, filenames are **provenance metadata**, not semantic content. Same rule as spans: "anchored to bytes, not narrated."

## INGESTED_DOC Node Type

### Payload (identity-participating, minimal)

```typescript
[NodeType.INGESTED_DOC]: {
  readonly snapshotHash: ContentHash;  // hash of raw bytes
  readonly mediaType: "text/plain" | "text/markdown" | "text/html";
  readonly origin: "PASTE" | "URL" | "UPLOAD";
};
```

### Provenance

```typescript
provenance: {
  source: "USER";
  artifact_ref: snapshotHash;  // must equal payload.snapshotHash
}
```

### What is NOT in the payload

| Field | Why excluded |
|---|---|
| `text` | Duplicates artifact store, balloons identity objects |
| `source_label` | Renames would create new node IDs, harming dedupe |
| `url` | Same — URL changes for same bytes shouldn't fork identity |
| `filename` | Same reasoning |

## ArtifactMetaStore (non-identity, display-only)

```typescript
type ArtifactMeta = {
  label?: string;       // "Q4 RFP PDF", "My notes"
  sourceUrl?: string;   // if origin === URL
  filename?: string;    // if upload
  capturedAt?: number;  // for display receipts
};

// Keyed by snapshotHash — same bytes, same metadata entry
metaStore.set(snapshotHash, meta);
```

Consistent with existing patterns: `RunEval` and UI state are already non-identity stores keyed by node/run IDs. This applies the same pattern to "human naming."

## Pipeline Duality (unchanged)

```
INGESTED_DOC → DOC_TEXT (canonical) → SPAN_CANDIDATE (slices)
```

Same as retrieval. No special casing.

## Run Semantics

- **Adding** a source → new child run with additional root anchors
- **Removing** a source → exclusion (same as Invalidate)
- **Undo** → select parent run (identical behavior)

Non-destructive. "I can't break it" safety preserved.

## G1 Invariant (stays uniform)

> Every CLAIM traces transitively to at least one VALID anchor node.

Anchor types: `RETRIEVAL_DOC | INGESTED_DOC`. G1 checks the type set, not a specific type.

## Ingestion Modes (v0.3 scope)

| Mode | Input | Constraint |
|---|---|---|
| PASTE | Raw text in textarea | Simplest path |
| UPLOAD | `.txt` / `.md` file | File reader API |
| URL | Paste URL content | CORS-limited in SPA — deferred or proxy |

**v0.3 minimum:** PASTE + UPLOAD. URL ingestion either requires pasting content manually or a tiny proxy with strict allowlist.

## Required Tests

1. G1 closure accepts both anchor types (RETRIEVAL_DOC and INGESTED_DOC)
2. Same bytes + different label → same `snapshotHash` → same node ID
3. Canonicalization canary: ingested CRLF/NFD text → same DOC_TEXT hash
4. Causal attribution BFS works through INGESTED_DOC ancestors
5. "Removed because [label]" — label sourced from ArtifactMetaStore, not payload

## Decisions to Lock Before Implementation

| Decision | Answer |
|---|---|
| Add INGESTED_DOC vs unify doc types? | Add separate type (clean, explicit) |
| Labels in identity? | **No.** Metadata store keyed by hash |
| Ingestion modes for v0.3? | PASTE + UPLOAD. URL deferred |
| Run semantics for add/remove? | Child runs (non-destructive) |
| Receipt rendering? | "User-provided" + label + capturedAt |
