# v0.3 Anchor Identity Design

**Status:** Design locked (pre-implementation)
**Depends on:** v0.2.2 freeze (real pilot must complete first)

## Core Principle

> An anchor node is identity-defined by the bytes it anchors to — not by how humans refer to it.

URLs, labels, filenames are **provenance metadata**, not semantic content. Same rule as spans: "anchored to bytes, not narrated."

## INGESTED_DOC Node Type

### Payload (identity-participating, minimal)

```typescript
[NodeType.INGESTED_DOC]: {
  readonly snapshotHash: ContentHash;  // hash of raw bytes
  readonly mediaType: "text/plain" | "text/markdown" | "text/html";
  readonly origin: "PASTE" | "URL" | "UPLOAD";
};
```

### Provenance

```typescript
provenance: {
  source: "USER";
  artifact_ref: snapshotHash;  // must equal payload.snapshotHash
}
```

### What is NOT in the payload

| Field | Why excluded |
|---|---|
| `text` | Duplicates artifact store, balloons identity objects |
| `source_label` | Renames would create new node IDs, harming dedupe |
| `url` | Same — URL changes for same bytes shouldn't fork identity |
| `filename` | Same reasoning |

## ArtifactMetaStore (non-identity, display-only)

```typescript
type ArtifactMeta = {
  labels: ReadonlyArray<{
    label: string;
    setBy: "USER" | "SYSTEM";
    runId?: string;        // allows per-run preferred label
    createdAt: number;
  }>;
  sourceUrl?: string;
  filename?: string;
  capturedAt?: number;
};

// Keyed by (namespace, snapshotHash)
// v0.3: namespace = "local" (single user)
// Future: namespace = workspaceId or userId
metaStore.set(namespace, snapshotHash, meta);
```

Consistent with existing patterns: `RunEval` and UI state are already non-identity stores keyed by node/run IDs.

## Label Policy (locked)

> Artifact metadata may contain multiple labels per hash. UI selects a deterministic preferred label (run-specific if available, else latest). Metadata is namespaced by workspace/user to prevent cross-tenant leakage.

**Display label resolution (deterministic):**

1. If there's a label entry for the current `runId`, use the most recent one for that run
2. Else use the most recent label overall
3. Else fallback to: `filename` (UPLOAD) → `hostname/path` (URL) → `"Pasted text"` (PASTE)

**Namespacing rule:** Artifact bytes and hashes are globally dedupable. Metadata is scoped to a namespace (`local` in v0.3, expandable to workspace/user later). Code must be structured so adding a namespace parameter is a small refactor, not an architectural change.

## Pipeline Duality (unchanged)

```
INGESTED_DOC → DOC_TEXT (canonical) → SPAN_CANDIDATE (slices)
```

Same as retrieval. No special casing.

## Run Semantics

- **Adding** a source → new child run with additional root anchors
- **Removing** a source → exclusion (same as Invalidate)
- **Undo** → select parent run (identical behavior)

Non-destructive. "I can't break it" safety preserved.

## G1 Invariant (stays uniform)

> Every CLAIM traces transitively to at least one VALID anchor node.

Anchor types: `RETRIEVAL_DOC | INGESTED_DOC`. G1 checks the type set, not a specific type.

## Ingestion Modes (v0.3 scope)

| Mode | Input | Constraint |
|---|---|---|
| PASTE | Raw text in textarea | Simplest path |
| UPLOAD | `.txt` / `.md` file | File reader API |
| URL | Paste URL content | CORS-limited in SPA — deferred or proxy |

**v0.3 minimum:** PASTE + UPLOAD. URL ingestion either requires pasting content manually or a tiny proxy with strict allowlist.

## Required Tests

1. G1 closure accepts both anchor types (RETRIEVAL_DOC and INGESTED_DOC)
2. Same bytes + different label → same `snapshotHash` → same node ID
3. Canonicalization canary: ingested CRLF/NFD text → same DOC_TEXT hash
4. Causal attribution BFS works through INGESTED_DOC ancestors
5. "Removed because [label]" — label sourced from ArtifactMetaStore, not payload

## Decisions to Lock Before Implementation

| Decision | Answer |
|---|---|
| Add INGESTED_DOC vs unify doc types? | Add separate type (clean, explicit) |
| Labels in identity? | **No.** Metadata store keyed by hash |
| Label collision policy? | **Multi-valued, run-scoped resolution.** No last-writer-wins |
| Metadata namespacing? | **Namespace-ready.** v0.3 uses `"local"`, structured for future expansion |
| Ingestion modes for v0.3? | PASTE + UPLOAD. URL deferred |
| Run semantics for add/remove? | Child runs (non-destructive) |
| Receipt rendering? | "User-provided" + label + capturedAt |
